{% extends 'index.html' %}
{% load form_extras %}

{% block title %}
    <div class="container" align="center">
        <div class="jumbotron">
            <h1>Enter New Sudoku</h1>
        </div>
    </div>
    <br>
{% endblock %}

{% block body %}
    {% if messages %}
        {% for message in messages %}
            <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                {{ message }}
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        {% endfor %}
    {% endif %}

    <div class="container" align="center">
{#        <div class="alert alert-info d-inline-block mt-3">#}
{#            <h5 class="mb-0">Cells Filled: <span id="cell-count">0/81</span></h5>#}
{#        </div>#}

        <div id="validation-message" class="mt-3 mb-3" style="min-height: 50px;"></div>

        <form method="POST" action="{% url 'new' %}" id="new-puzzle-form">
            {% csrf_token %}

            <div class="row justify-content-center">
                <div class="col-md-4">
                    <label>Set Difficulty Level:</label>
                    {{ form.difficulty }}
                </div>
            </div>

            <br>

            <table class="board">
                <tr>
                    <td class="first_index"></td>
                    {% for i in "123456789" %}
                        <td class="top_index">{{ i }}</td>
                    {% endfor %}
                </tr>

                {% for row_char in "ABCDEFGHI" %}
                <tr>
                    <td class="left_index">{{ row_char }}</td>
                    {% for col_num in "123456789" %}
                        {% with field_name=row_char|add:col_num %}
                            <td class="{% if col_num in '36' %}right{% endif %} {% if row_char in 'CF' %}bottom{% endif %} {% if col_num in '36' and row_char in 'CF' %}rb{% endif %}">
                                {{ form|get_field:field_name }}
                            </td>
                        {% endwith %}
                    {% endfor %}
                </tr>
                {% endfor %}
            </table>
            <br>
            <button type="submit" class="btn btn-primary btn-lg" id="submit-btn">Create Puzzle</button>
        </form>
    </div>

    <script>
        let validationTimeout;
        let isValid = false;
        const rows = 'ABCDEFGHI';
        const cols = '123456789';

        document.addEventListener('DOMContentLoaded', function() {
            const cells = document.querySelectorAll('.cell');
            const submitBtn = document.getElementById('submit-btn');

            cells.forEach(cell => {
                cell.addEventListener('input', function(e) {
                    this.value = this.value.replace(/[^1-9]/g, '');

                    clearTimeout(validationTimeout);
                    validationTimeout = setTimeout(() => {
                        validateGrid();
                        updateCellCount();
                    }, 400);

                    updateCellCount();
                });
            });

            document.getElementById('new-puzzle-form').addEventListener('submit', function(e) {
                const filledCells = Array.from(cells).filter(c => c.value).length;

                if (filledCells < 17) {
                    e.preventDefault();
                    showMessage('A valid Sudoku puzzle needs at least 17 filled cells!', 'warning');
                    return;
                }

                if (!isValid) {
                    e.preventDefault();
                    showMessage('Please fix the duplicate errors before submitting', 'danger');
                    validateGrid();
                }
            });

            updateCellCount();
        });

        function updateCellCount() {
            const cells = document.querySelectorAll('.cell');
            const filledCount = Array.from(cells).filter(c => c.value).length;
            document.getElementById('cell-count').textContent = `${filledCount}/81`;
        }

        function validateGrid() {
            const cells = document.querySelectorAll('.cell');
            let gridData = {};
            let hasAnyInput = false;

            cells.forEach(cell => {
                if (cell.name) {
                    gridData[cell.name] = cell.value || '.';
                    if (cell.value) hasAnyInput = true;
                }
            });

            // Clear previous highlights
            cells.forEach(cell => {
                cell.classList.remove('is-invalid', 'is-valid');
                cell.closest('td').classList.remove('is-invalid', 'is-valid');
            });

            if (!hasAnyInput) {
                clearMessage();
                isValid = true;
                return;
            }

            let duplicates = findDuplicates(gridData);

            if (duplicates.length > 0) {
                // Highlight all cells involved in duplicates
                duplicates.forEach(cellKey => {
                    const inputElement = document.querySelector(`[name="${cellKey}"]`);
                    if (inputElement && inputElement.value) {
                        inputElement.classList.add('is-invalid');
                        inputElement.closest('td').classList.add('is-invalid');
                    }
                });

                showMessage(`⚠️ ${duplicates.length} duplicate(s) found! Fix them to continue.`, 'danger');
                isValid = false;
            } else {
                // Mark all filled cells as valid
                cells.forEach(cell => {
                    if (cell.value) {
                        cell.classList.add('is-valid');
                        cell.closest('td').classList.add('is-valid');
                    }
                });

                const filledCount = Array.from(cells).filter(c => c.value).length;
                if (filledCount >= 17) {
                    showMessage('✓ Grid is valid! Ready to create puzzle.', 'success');
                } else {
                    showMessage(`Grid valid, but needs ${17 - filledCount} more cells (minimum 17)`, 'info');
                }
                isValid = true;
            }
        }

        function findDuplicates(gridData) {
            let duplicates = new Set();

            // Check rows
            for (let row of rows) {
                let seen = {};
                for (let col of cols) {
                    let key = row + col;
                    let value = gridData[key];
                    if (value !== '.') {
                        if (seen[value]) {
                            duplicates.add(key);
                            duplicates.add(seen[value]);
                        } else {
                            seen[value] = key;
                        }
                    }
                }
            }

            // Check columns
            for (let col of cols) {
                let seen = {};
                for (let row of rows) {
                    let key = row + col;
                    let value = gridData[key];
                    if (value !== '.') {
                        if (seen[value]) {
                            duplicates.add(key);
                            duplicates.add(seen[value]);
                        } else {
                            seen[value] = key;
                        }
                    }
                }
            }

            // Check 3x3 blocks
            const blockRows = [['A','B','C'], ['D','E','F'], ['G','H','I']];
            const blockCols = [['1','2','3'], ['4','5','6'], ['7','8','9']];

            for (let blockRow of blockRows) {
                for (let blockCol of blockCols) {
                    let seen = {};
                    for (let row of blockRow) {
                        for (let col of blockCol) {
                            let key = row + col;
                            let value = gridData[key];
                            if (value !== '.') {
                                if (seen[value]) {
                                    duplicates.add(key);
                                    duplicates.add(seen[value]);
                                } else {
                                    seen[value] = key;
                                }
                            }
                        }
                    }
                }
            }

            return Array.from(duplicates);
        }

        function showMessage(text, type) {
            const container = document.getElementById('validation-message');
            container.innerHTML = '';

            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
            alertDiv.setAttribute('role', 'alert');

            const textNode = document.createTextNode(text);
            alertDiv.appendChild(textNode);

            const closeButton = document.createElement('button');
            closeButton.type = 'button';
            closeButton.className = 'btn-close';
            closeButton.setAttribute('data-bs-dismiss', 'alert');
            closeButton.setAttribute('aria-label', 'Close');

            {#alertDiv.appendChild(closeButton);#}
            container.appendChild(alertDiv);
            setTimeout(clearMessage, 1000);
        }

        function clearMessage() {
            document.getElementById('validation-message').innerHTML = '';
        }
    </script>
{% endblock %}